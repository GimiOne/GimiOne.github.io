<!doctype HTML public "-//W3O//DTD W3 HTML 3.0//EN">
<HTML>
<HEAD>
<TITLE>Перевод: Поляков А.В. http://www.avprog.narod.ru</TITLE>
<META name="description" content="Interrupts - 8086 Assembler">
<META name="keywords" content="interrupts, 8086, tutorial, programming, assembler tutorial, tutorial for begginers">
<META name="robots" content="nofollow">
</HEAD><BODY bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#007099" alink="#FF0000">
<TABLE WIDTH=80%>
<TR><TD>
<FONT FACE="Verdana" SIZE=3>
<FONT SIZE=+1>
<B>Уроки Ассемблера 8086 для начинающих (Часть 8)</B>
</FONT><BR><BR>
<FONT SIZE=+2><B>Процедуры</B></FONT>
<BR><BR>
<FONT SIZE=1>
Перевод: Поляков А.В. <A HREF="http://www.avprog.narod.ru">http://www.avprog.narod.ru</A>
</FONT><BR><BR><BR>

Процедура - это часть кода, которая может быть вызвана из вашей
программы для выполнения какой-либо определенной задачи. Процедуры
делают программу более структурной и доступной для понимания. В общем
случае процедура возвращает программу к той же самой точке, откуда
она была вызвана.
<BR><BR>
 Синтаксис для объявления процедуры:
 <BLOCKQUOTE>
 <FONT FACE="Fixedsys">
 <U>имя</U> PROC<BR><BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ; здесь находится<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ;  код процедуры ...<BR><BR>
 RET<BR>
 <U>имя</U> ENDP

 </FONT>
 </BLOCKQUOTE>

<BR>
<U>имя</U> - это имя процедуры. Одно и то же имя должно быть в верхней
и нижней части, это используется для проверки правильности закрытия
процедур.
<BR><BR>
Возможно, вы уже знаете, что команда <B>RET</B> используется для
возвращения в операционную систему. Эта же команда используется для
возвращения из процедуры (фактически операционная система воспринимает
вашу программу, как специальную процедуру).
<BR><BR>
<B>PROC</B> и <B>ENDP</B> - это директивы компилятора, поэтому они не
ассемблируются в какой-либо реальный машинный код. Компилятор только
запоминает адрес процедуры.
<BR><BR>
Команда <B>CALL</B> используется для вызова процедуры.
<BR><BR>
Пример:
<BR><BR>

<TABLE BORDER=1 CELLPADDING=10 WIDTH=50%><TR><TD>
<PRE><FONT FACE="Fixedsys">
ORG    100h

CALL   m1

MOV    AX, 2

RET                   ; вернуться в операционную систему.

m1     PROC
MOV    BX, 5
RET                   ; вернуться в программу, из которой была вызвана.
m1     ENDP

END</FONT></PRE>
</TD></TR></TABLE>

<BR><BR>

Вышеописанный пример вызывает процедуру <B>m1</B>, которая выполняет
команду <B>MOV BX, 5</B>. После окончания процедуры, программа
выполняет команду, следующую после команды <B>CALL</B>, т.е. команду: <B>MOV AX, 2</B>.

<BR><BR>
Есть несколько способов передачи параметров процедуре. Самый простой из них -
использование регистров. Здесь представлен пример процедуры, которая
принимает два параметра в регистрах <B>AL</B> и <B>BL</B>, умножает
их и возвращает результат в регистр <B>AX</B>:
<BR><BR>

<TABLE BORDER=1 CELLPADDING=10 WIDTH=50%><TR><TD>
<PRE><FONT FACE="Fixedsys">
ORG    100h

MOV    AL, 1
MOV    BL, 2

CALL   m2
CALL   m2
CALL   m2
CALL   m2

RET                   ; вернуться в операционную систему.

m2     PROC
MUL    BL             ; AX = AL * BL.
RET                   ; вернуться в вызвавшую программу.
m2     ENDP

END</FONT></PRE>
</TD></TR></TABLE>

<BR><BR>
В этом примере значение регистра <B>AL</B> изменяется каждый раз при
вызове процедуры, а состояние регистра <B>BL</B> не изменяется. Таким
образом мы получили алгоритм вычисления числа <B>2</B> в <B>4</B>-ой степени.<BR>
В результате в регистре <B>AX</B> будет число <B>16</B> (или 10h).

<BR><BR>
<HR>
<BR>

Здесь дан другой пример, в котором используется процедура для вывода
на экран сообщения <I>Hello World!</I>:
<BR><BR>

<TABLE BORDER=1 CELLPADDING=10 WIDTH=50%><TR><TD>
<PRE><FONT FACE="Fixedsys">
ORG    100h

LEA    SI, msg        ; загрузить адрес msg в регистр SI.

CALL   print_me

RET                   ; вернуться в ОС.

; ==========================================================
; эта процедура печатает строку, строка должна оканчиваться
; нулем (иметь ноль в конце), адрес строки дожен быть в
; регистреhe SI:
print_me     PROC

next_char:
    CMP  b.[SI], 0    ; проверить регистр SI, если он
    JE   stop         ; равен 0, перейти к метке stop

    MOV  AL, [SI]     ; иначе получить ASCII-символ.

    MOV  AH, 0Eh      ; номер функции для печати символа.
    INT  10h          ; используем прерывание для печати
                      ; символа из AL.

    ADD  SI, 1        ; увеличить индекс строкового массива

    JMP  next_char    ; вернуться и напечатать другой символ

stop:
RET                   ; вернуться в программу.
print_me     ENDP
; ==========================================================

msg    DB  'Hello World!', 0   ; строка с нулевым окончанием

END</FONT></PRE>
</TD></TR></TABLE>

<BR><BR>
"<B>b.</B>" - префикс перед [SI] означает, что нам необходимо
сравнивать байты, а не слова. Если вы хотите сравнить слова, добавьте
префикс "<B>w.</B>" вместо "<B>b.</B>". Если один из сравниваемых
операторов - регистр, то вставлять префиксы не требуется, так как
компилятор знает размер каждого регистра.

<BR><BR><BR>

<HR>
<CENTER>
<A HREF="asm_tutorial_07.html"><B> &lt;&lt;&lt; Предыдущая часть &lt;&lt;&lt; </B></A>
&nbsp;&nbsp;&nbsp;&nbsp;
<A HREF="asm_tutorial_09.html"><B> >>> Следующая часть >>> </B></A>
</CENTER>
<HR>


<BR>

</FONT>



</TD></TR>
</TABLE>



</BODY>

</HTML>
